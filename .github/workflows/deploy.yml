name: Deploy Minimal Notes to GitHub Pages

on:
  push:
    branches: [ main ]
    paths:
      - 'minimal_notes_web.zip'
      - '.github/workflows/deploy.yml'

permissions:
  contents: write

concurrency:
  group: pages-deploy
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: sudo apt-get update && sudo apt-get install -y unzip xz-utils curl

      - name: Unzip project
        run: unzip -o minimal_notes_web.zip

      - name: Detect project dir (where pubspec.yaml + lib/ are)
        id: detect
        shell: bash
        run: |
          set -e
          DIR="$(find . -maxdepth 3 -type f -name pubspec.yaml -print -quit)"
          if [[ -z "$DIR" ]]; then
            echo "No pubspec.yaml found after unzip" >&2
            exit 1
          fi
          PROJ_DIR="$(dirname "$DIR")"
          if [[ ! -d "$PROJ_DIR/lib" ]]; then
            echo "lib/ not found next to pubspec.yaml ($PROJ_DIR)" >&2
            exit 1
          fi
          echo "DIR=$PROJ_DIR" >> "$GITHUB_OUTPUT"
          echo "Project dir: $PROJ_DIR"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Enable web
        run: flutter config --enable-web

      - name: Ensure web platform
        working-directory: ${{ steps.detect.outputs.DIR }}
        run: flutter create . --platforms web

      # Вживляем рабочий pdf_export.dart (кириллица + same-tab, без попапов)
      - name: Overwrite lib/services/pdf_export.dart
        working-directory: ${{ steps.detect.outputs.DIR }}
        shell: bash
        run: |
          mkdir -p lib/services
          cat > lib/services/pdf_export.dart <<'DART'
// lib/services/pdf_export.dart
import 'dart:typed_data';
import 'dart:html' as html;
import 'dart:async';

import 'package:flutter/services.dart' show rootBundle;
import 'package:intl/intl.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart';
import 'package:hive/hive.dart';

import '../models/task.dart';
import '../models/subitem.dart';
import '../models/attachment.dart';

enum PdfVariant { checklist, detailed }

class PdfExporter {
  Future<void> exportTask(String taskId, PdfVariant variant, {int days = 28}) async {
    final tasks = Hive.box<Task>('tasks');
    final subs = Hive.box<Subitem>('subitems');
    final atts = Hive.box<Attachment>('attachments');

    final task = tasks.get(taskId);
    if (task == null) return;

    final subitems = subs.values.where((s) => s.taskId == taskId).toList()
      ..sort((a, b) => a.createdAt.compareTo(b.createdAt));

    final attsBySub = <String, List<Attachment>>{};
    for (final s in subitems) {
      attsBySub[s.id] = atts.values.where((a) => a.subitemId == s.id).toList()
        ..sort((a, b) => a.createdAt.compareTo(b.createdAt));
    }

    // Fonts: try assets first, else fetch from CDN, else Helvetica
    final fonts = await _loadFonts();
    final theme = pw.ThemeData.withFont(base: fonts.$1, bold: fonts.$2);

    final doc = pw.Document();

    if (variant == PdfVariant.checklist) {
      final start = DateTime(task.createdAt.year, task.createdAt.month, task.createdAt.day);
      int generated = 0;
      while (generated < days) {
        final remain = days - generated;
        final span = remain >= 7 ? 7 : remain; // paginate by weeks
        final dates = List.generate(span, (i) => start.add(Duration(days: generated + i)));
        doc.addPage(
          pw.MultiPage(
            theme: theme,
            pageTheme: _theme(landscape: true),
            build: (ctx) => [
              pw.Header(level: 0, child: pw.Text('Чек-лист: ${task.title}', style: pw.TextStyle(fontSize: 22, font: fonts.$2))),
              pw.Text('Период: ${DateFormat('dd.MM').format(dates.first)} – ${DateFormat('dd.MM').format(dates.last)}', style: pw.TextStyle(font: fonts.$1)),
              pw.SizedBox(height: 10),
              _checklistTable(subitems.where((s) => s.type == SubitemType.subtask).toList(), dates, fonts.$1, fonts.$2),
            ],
          ),
        );
        generated += span;
      }
    } else {
      doc.addPage(
        pw.MultiPage(
          theme: theme,
          pageTheme: _theme(),
          build: (ctx) => [
            pw.Header(level: 0, child: pw.Text(task.title, style: pw.TextStyle(fontSize: 24, font: fonts.$2))),
            pw.Text('Экспорт: ${DateFormat('yyyy-MM-dd HH:mm').format(DateTime.now())}', style: pw.TextStyle(font: fonts.$1)),
            pw.SizedBox(height: 12),
            ..._detailedBlocks(subitems, attsBySub, fonts.$1, fonts.$2),
          ],
        ),
      );
    }

    final Uint8List bytes = await doc.save();

    // SAME-TAB: навигируем текущую вкладку на Blob-URL → без попапов на мобилках
    final url = html.Url.createObjectUrlFromBlob(html.Blob([bytes], 'application/pdf'));
    Future<void>.delayed(const Duration(seconds: 1)).then((_) {
      try { html.Url.revokeObjectUrl(url); } catch (_) {}
    });
    html.window.location.href = url;
  }

  Future<(pw.Font, pw.Font)> _loadFonts() async {
    // 1) assets (если есть)
    try {
      final reg = await rootBundle.load('assets/fonts/NotoSans-Regular.ttf');
      final bld = await rootBundle.load('assets/fonts/NotoSans-Bold.ttf');
      return (pw.Font.ttf(reg), pw.Font.ttf(bld));
    } catch (_) {
      // 2) CDN (работает на GitHub Pages)
      try {
        final reg = await _fetchFont('https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/notosans/NotoSans-Regular.ttf');
        final bld = await _fetchFont('https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/notosans/NotoSans-Bold.ttf');
        return (reg, bld);
      } catch (_) {
        // 3) запасной вариант
        return (pw.Font.helvetica(), pw.Font.helveticaBold());
      }
    }
  }

  Future<pw.Font> _fetchFont(String url) async {
    final resp = await html.HttpRequest.request(url, method: 'GET', responseType: 'arraybuffer');
    final buf = resp.response as ByteBuffer;
    final bytes = Uint8List.view(buf);
    return pw.Font.ttf(bytes.buffer.asByteData());
  }

  pw.PageTheme _theme({bool landscape = false}) => pw.PageTheme(
    pageFormat: landscape ? PdfPageFormat.a4.landscape : PdfPageFormat.a4,
    margin: const pw.EdgeInsets.all(24),
  );

  pw.Widget _checklistTable(List<Subitem> subtasks, List<DateTime> dates, pw.Font fontBase, pw.Font fontBold) {
    final dateFmt = DateFormat('dd.MM');
    final headers = <pw.Widget>[
      pw.Container(padding: const pw.EdgeInsets.all(6), child: pw.Text('Подзадача', style: pw.TextStyle(font: fontBold))),
      ...dates.map((d) => pw.Center(child: pw.Text(dateFmt.format(d), style: pw.TextStyle(fontSize: 10, font: fontBase)))),
    ];
    final rows = subtasks.map<pw.TableRow>((s) {
      return pw.TableRow(children: [
        pw.Container(padding: const pw.EdgeInsets.all(6), child: pw.Text(s.title, maxLines: 1, style: pw.TextStyle(font: fontBase))),
        ...dates.map((d) => pw.Container(height: 20, margin: const pw.EdgeInsets.symmetric(vertical: 4, horizontal: 2), decoration: pw.BoxDecoration(border: pw.Border.all(color: PdfColors.grey600, width: 0.5)))),
      ]);
    }).toList();

    return pw.Table(
      border: pw.TableBorder.all(color: PdfColors.grey600, width: 0.6),
      defaultVerticalAlignment: pw.TableCellVerticalAlignment.middle,
      columnWidths: { 0: const pw.FlexColumnWidth(3), for (int i = 1; i <= dates.length; i++) i: const pw.FlexColumnWidth(1), },
      children: [ pw.TableRow(decoration: const pw.BoxDecoration(color: PdfColors.grey200), children: headers), ...rows ],
    );
  }

  List<pw.Widget> _detailedBlocks(List<Subitem> items, Map<String, List<Attachment>> attBySub, pw.Font fontBase, pw.Font fontBold) {
    final widgets = <pw.Widget>[];
    for (final s in items) {
      if (s.type == SubitemType.folder) {
        widgets.add(pw.Padding(padding: const pw.EdgeInsets.only(top: 12, bottom: 4), child: pw.Text('Папка: ${s.title}', style: pw.TextStyle(font: fontBold, fontSize: 16))));
        continue;
      }
      widgets.add(pw.Padding(padding: const pw.EdgeInsets.only(top: 12, bottom: 4), child: pw.Text('Подзадача: ${s.title}', style: pw.TextStyle(font: fontBold, fontSize: 14))));
      if (s.note != null && s.note!.trim().isNotEmpty) {
        widgets.add(pw.Padding(padding: const pw.EdgeInsets.only(bottom: 6), child: pw.Text(s.note!, style: pw.TextStyle(font: fontBase))));
      }
      final atts = attBySub[s.id] ?? const <Attachment>[];
      final images = atts.where((a) => a.mimeType.startsWith('image/')).toList();
      final others = atts.where((a) => !a.mimeType.startsWith('image/')).toList();

      if (images.isNotEmpty) {
        widgets.add(pw.Wrap(spacing: 8, runSpacing: 8, children: images.map((a) {
          final img = pw.MemoryImage(a.bytes);
          return pw.Container(width: 170, height: 128, decoration: pw.BoxDecoration(border: pw.Border.all(color: PdfColors.grey600, width: 0.5)), child: pw.ClipRRect(verticalRadius: 2, horizontalRadius: 2, child: pw.Image(img, fit: pw.BoxFit.cover)));
        }).toList()));
      }
      if (others.isNotEmpty) {
        widgets.add(pw.Padding(padding: const pw.EdgeInsets.only(top: 6), child: pw.Column(crossAxisAlignment: pw.CrossAxisAlignment.start, children: [
          pw.Text('Файлы:', style: pw.TextStyle(font: fontBold)),
          ...others.map((a) => pw.Text('• ${a.filename}', style: pw.TextStyle(font: fontBase))).toList(),
        ])));
      }
      widgets.add(pw.Divider());
    }
    return widgets;
  }
}
DART

      - name: Flutter pub get
        working-directory: ${{ steps.detect.outputs.DIR }}
        run: flutter pub get

      - name: Compute base-href
        id: base
        shell: bash
        run: |
          REPO="${GITHUB_REPOSITORY#*/}"
          if [[ "$REPO" == *.github.io ]]; then
            echo "BASE=/" >> "$GITHUB_OUTPUT"
          else
            echo "BASE=/$REPO/" >> "$GITHUB_OUTPUT"
          fi
          echo "Using base-href: ${{ steps.base.outputs.BASE }}"

      - name: Build web (release)
        working-directory: ${{ steps.detect.outputs.DIR }}
        run: flutter build web --release --no-wasm-dry-run --base-href "${{ steps.base.outputs.BASE }}"

      - name: Write version.json
        working-directory: ${{ steps.detect.outputs.DIR }}
        run: |
          mkdir -p build/web
          echo "{\"version\":\"${GITHUB_SHA}\"}" > build/web/version.json
          cat build/web/version.json

      - name: Deploy to gh-pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ${{ steps.detect.outputs.DIR }}/build/web
          force_orphan: true
