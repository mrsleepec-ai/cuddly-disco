name: Deploy Minimal Notes to GitHub Pages

on:
  push:
    branches: [ main ]
    paths:
      - 'minimal_notes_web.zip'
      - '.github/workflows/deploy.yml'

permissions:
  contents: write

concurrency:
  group: pages-deploy
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: sudo apt-get update && sudo apt-get install -y unzip xz-utils curl

      - name: Unzip project
        run: unzip -o minimal_notes_web.zip

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Enable web
        run: flutter config --enable-web

      # 1) Чистый pubspec.yaml c ОДНИМ блоком assets (включая шрифты)
      - name: Sanitize pubspec.yaml (single assets block)
        working-directory: minimal_notes_web
        run: |
          cat > pubspec.yaml <<'YML'
          name: minimal_notes_web
          description: Minimal notes & tasks app for Web with checklist/detailed PDF
          publish_to: "none"

          environment:
            sdk: ">=3.3.0 <4.0.0"

          dependencies:
            flutter:
              sdk: flutter
            cupertino_icons: ^1.0.8
            flutter_riverpod: ^2.5.1
            uuid: ^4.4.0
            hive: ^2.2.3
            hive_flutter: ^1.1.0
            image_picker: ^1.1.2
            file_picker: ^8.0.2
            pdf: ^3.11.1
            printing: ^5.13.1
            intl: ^0.19.0

          dev_dependencies:
            flutter_test:
              sdk: flutter
            flutter_lints: ^4.0.0

          flutter:
            uses-material-design: true
            assets:
              - assets/
              - assets/fonts/NotoSans-Regular.ttf
              - assets/fonts/NotoSans-Bold.ttf
          YML

      # 2) Перезаписываем pdf_export.dart гарантированно корректным кодом
      - name: Overwrite lib/services/pdf_export.dart (Cyrillic + open PDF)
        working-directory: minimal_notes_web
        run: |
          mkdir -p lib/services
          cat > lib/services/pdf_export.dart <<'DART'
// lib/services/pdf_export.dart
import 'dart:typed_data';
import 'dart:html' as html;

import 'package:flutter/services.dart' show rootBundle;
import 'package:intl/intl.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart';
import 'package:hive/hive.dart';

import '../models/task.dart';
import '../models/subitem.dart';
import '../models/attachment.dart';

enum PdfVariant { checklist, detailed }

class PdfExporter {
  Future<void> exportTask(String taskId, PdfVariant variant, {int days = 28}) async {
    final tasks = Hive.box<Task>('tasks');
    final subs = Hive.box<Subitem>('subitems');
    final atts = Hive.box<Attachment>('attachments');

    final task = tasks.get(taskId)!;

    final subitems = subs.values
        .where((s) => s.taskId == taskId)
        .toList()
      ..sort((a, b) => a.createdAt.compareTo(b.createdAt));

    final attsBySub = <String, List<Attachment>>{};
    for (final s in subitems) {
      attsBySub[s.id] = atts.values
          .where((a) => a.subitemId == s.id)
          .toList()
        ..sort((a, b) => a.createdAt.compareTo(b.createdAt));
    }

    // ==== ВСТРОЕННЫЕ ШРИФТЫ (КИРИЛЛИЦА) ====
    late final pw.Font fontBase;
    late final pw.Font fontBold;
    pw.ThemeData theme;
    try {
      final reg = await rootBundle.load('assets/fonts/NotoSans-Regular.ttf');
      final bld = await rootBundle.load('assets/fonts/NotoSans-Bold.ttf');
      fontBase = pw.Font.ttf(reg);
      fontBold = pw.Font.ttf(bld);
      theme = pw.ThemeData.withFont(base: fontBase, bold: fontBold);
    } catch (_) {
      // Фолбэк, если ассеты не попали в билд
      fontBase = pw.Font.helvetica();
      fontBold = pw.Font.helveticaBold();
      theme = pw.ThemeData.withFont(base: fontBase, bold: fontBold);
    }

    final doc = pw.Document();

    if (variant == PdfVariant.checklist) {
      final start = DateTime(task.createdAt.year, task.createdAt.month, task.createdAt.day);
      int generated = 0;
      while (generated < days) {
        final remain = days - generated;
        final span = remain >= 7 ? 7 : remain;
        final dates = List.generate(span, (i) => start.add(Duration(days: generated + i)));

        doc.addPage(
          pw.MultiPage(
            theme: theme,
            pageTheme: _theme(landscape: true),
            build: (ctx) => [
              pw.Header(
                level: 0,
                child: pw.Text('Чек-лист: ${task.title}', style: pw.TextStyle(fontSize: 22, font: fontBold)),
              ),
              pw.Text(
                'Период: ${DateFormat('dd.MM').format(dates.first)} – ${DateFormat('dd.MM').format(dates.last)}',
                style: pw.TextStyle(font: fontBase),
              ),
              pw.SizedBox(height: 10),
              _checklistTable(
                subitems.where((s) => s.type == SubitemType.subtask).toList(),
                dates,
                fontBase,
                fontBold,
              ),
            ],
          ),
        );

        generated += span;
      }
    } else {
      doc.addPage(
        pw.MultiPage(
          theme: theme,
          pageTheme: _theme(),
          build: (ctx) => [
            pw.Header(
              level: 0,
              child: pw.Text(task.title, style: pw.TextStyle(fontSize: 24, font: fontBold)),
            ),
            pw.Text(
              'Экспорт: ${DateFormat('yyyy-MM-dd HH:mm').format(DateTime.now())}',
              style: pw.TextStyle(font: fontBase),
            ),
            pw.SizedBox(height: 12),
            ..._detailedBlocks(subitems, attsBySub, fontBase, fontBold),
          ],
        ),
      );
    }

    // ==== Сохранить и ОТКРЫТЬ/СКАЧАТЬ PDF В БРАУЗЕРЕ ====
    final Uint8List bytes = await doc.save();
    final fname = 'task_${task.title.replaceAll(' ', '_')}_${variant.name}.pdf';

    final blob = html.Blob([bytes], 'application/pdf');
    final url = html.Url.createObjectUrlFromBlob(blob);
    final a = html.AnchorElement(href: url)
      ..target = '_blank'
      ..download = fname;
    a.click();
    html.Url.revokeObjectUrl(url);
  }

  pw.PageTheme _theme({bool landscape = false}) => pw.PageTheme(
        pageFormat: landscape ? PdfPageFormat.a4.landscape : PdfPageFormat.a4,
        margin: const pw.EdgeInsets.all(24),
      );

  pw.Widget _checklistTable(
    List<Subitem> subtasks,
    List<DateTime> dates,
    pw.Font fontBase,
    pw.Font fontBold,
  ) {
    final dateFmt = DateFormat('dd.MM');

    final headers = <pw.Widget>[
      pw.Container(
        padding: const pw.EdgeInsets.all(6),
        child: pw.Text('Подзадача', style: pw.TextStyle(font: fontBold)),
      ),
      ...dates.map(
        (d) => pw.Center(
          child: pw.Text(dateFmt.format(d), style: pw.TextStyle(fontSize: 10, font: fontBase)),
        ),
      ),
    ];

    final rows = subtasks.map<pw.TableRow>((s) {
      return pw.TableRow(
        children: [
          pw.Container(
            padding: const pw.EdgeInsets.all(6),
            child: pw.Text(s.title, maxLines: 1, style: pw.TextStyle(font: fontBase)),
          ),
          ...dates.map(
            (d) => pw.Container(
              height: 20,
              margin: const pw.EdgeInsets.symmetric(vertical: 4, horizontal: 2),
              decoration: pw.BoxDecoration(
                border: pw.Border.all(color: PdfColors.grey600, width: 0.5),
              ),
            ),
          ),
        ],
      );
    }).toList();

    return pw.Table(
      border: pw.TableBorder.all(color: PdfColors.grey600, width: 0.6),
      defaultVerticalAlignment: pw.TableCellVerticalAlignment.middle,
      columnWidths: {
        0: const pw.FlexColumnWidth(3),
        for (int i = 1; i <= dates.length; i++) i: const pw.FlexColumnWidth(1),
      },
      children: [
        pw.TableRow(
          decoration: const pw.BoxDecoration(color: PdfColors.grey200),
          children: headers,
        ),
        ...rows,
      ],
    );
  }

  List<pw.Widget> _detailedBlocks(
    List<Subitem> items,
    Map<String, List<Attachment>> attBySub,
    pw.Font fontBase,
    pw.Font fontBold,
  ) {
    final widgets = <pw.Widget>[];

    for (final s in items) {
      if (s.type == SubitemType.folder) {
        widgets.add(
          pw.Padding(
            padding: const pw.EdgeInsets.only(top: 12, bottom: 4),
            child: pw.Text('Папка: ${s.title}', style: pw.TextStyle(font: fontBold, fontSize: 16)),
          ),
        );
        continue;
      }

      widgets.add(
        pw.Padding(
          padding: const pw.EdgeInsets.only(top: 12, bottom: 4),
          child: pw.Text('Подзадача: ${s.title}', style: pw.TextStyle(font: fontBold, fontSize: 14)),
        ),
      );

      if (s.note != null && s.note!.trim().isNotEmpty) {
        widgets.add(
          pw.Padding(
            padding: const pw.EdgeInsets.only(bottom: 6),
            child: pw.Text(s.note!, style: pw.TextStyle(font: fontBase)),
          ),
        );
      }

      final atts = attBySub[s.id] ?? const <Attachment>[];
      final images = atts.where((a) => a.mimeType.startsWith('image/')).toList();
      final others = atts.where((a) => !a.mimeType.startsWith('image/')).toList();

      if (images.isNotEmpty) {
        widgets.add(
          pw.Wrap(
            spacing: 8,
            runSpacing: 8,
            children: images.map((a) {
              final img = pw.MemoryImage(a.bytes);
              return pw.Container(
                width: 170,
                height: 128,
                decoration: pw.BoxDecoration(border: pw.Border.all(color: PdfColors.grey600, width: 0.5)),
                child: pw.ClipRRect(
                  verticalRadius: 2,
                  horizontalRadius: 2,
                  child: pw.Image(img, fit: pw.BoxFit.cover),
                ),
              );
            }).toList(),
          ),
        );
      }

      if (others.isNotEmpty) {
        widgets.add(
          pw.Padding(
            padding: const pw.EdgeInsets.only(top: 6),
            child: pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Text('Файлы:', style: pw.TextStyle(font: fontBold)),
                ...others.map((a) => pw.Text('• ${a.filename}', style: pw.TextStyle(font: fontBase))).toList(),
              ],
            ),
          ),
        );
      }

      widgets.add(pw.Divider());
    }

    return widgets;
  }
}
DART

      # 3) Создаём web-папки, если их нет
      - name: Ensure web platform
        working-directory: minimal_notes_web
        run: flutter create . --platforms web

      # 4) Скачиваем TTF (вшиваем в ассеты)
      - name: Download NotoSans fonts (Cyrillic)
        working-directory: minimal_notes_web
        run: |
          mkdir -p assets/fonts
          curl -L -o assets/fonts/NotoSans-Regular.ttf https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/notosans/NotoSans-Regular.ttf
          curl -L -o assets/fonts/NotoSans-Bold.ttf https://cdn.jsdelivr.net/gh/google/fonts@main/ofl/notosans/NotoSans-Bold.ttf
          ls -la assets/fonts

      - name: Pub get
        working-directory: minimal_notes_web
        run: flutter pub get

      - name: Compute base-href
        id: base
        run: |
          REPO_NAME=${GITHUB_REPOSITORY#*/}
          if [[ "$REPO_NAME" == *.github.io ]]; then
            echo "BASE=/" >> $GITHUB_OUTPUT
          else
            echo "BASE=/$REPO_NAME/" >> $GITHUB_OUTPUT
          fi

      - name: Build web (release)
        working-directory: minimal_notes_web
        run: flutter build web --release --no-wasm-dry-run --base-href "${{ steps.base.outputs.BASE }}"

      - name: Write version.json
        working-directory: minimal_notes_web
        run: |
          mkdir -p build/web
          echo "{\"version\":\"${GITHUB_SHA}\"}" > build/web/version.json

      - name: Deploy to gh-pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: minimal_notes_web/build/web
          force_orphan: true
